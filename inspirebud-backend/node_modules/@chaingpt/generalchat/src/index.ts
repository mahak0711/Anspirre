import axios, { AxiosInstance } from 'axios';
import { CreateChatDto, FindChatDto, HeaderDto } from './dto';
import { SERVER_URL, TIMEOUT } from './config';
import { InvalidApiKeyError, GeneralChatError, GeneralChatHistoryError, RateLimitExceededError } from './error';
import { Readable, finished } from 'stream';
import { promisify } from 'util';

export class GeneralChat {
  apiKey: string;

  constructor(obj: HeaderDto) {
    this.apiKey = obj.apiKey;
  }

  /**
   * 
   * @param createChatDto {
   * question:string,
   * chatHistory: on/off
   * }
   * @returns 
   */
  async createChatStream(createChatDto: CreateChatDto): Promise<any> {   
    const obj: any = createChatDto;
    Object.keys(createChatDto).forEach((key) => {
      const typedKey = key as keyof CreateChatDto;
      if (createChatDto[typedKey] === undefined) {
        delete obj[typedKey];
      }
    });
    obj['model'] = 'general_assistant';
    const instance: AxiosInstance = axios.create({
      baseURL: SERVER_URL,
      timeout: TIMEOUT,
      headers: { 'Authorization': `Bearer ${this.apiKey}` },
      responseType: 'stream'
    });
    instance.interceptors.response.use((response)=>{
      return response;
    },
    async (error)=>{
      let data = "";
      await promisify(finished)(
        error.response.data.on("data", (chunk: Buffer) => {
          data += chunk.toString();
        })
      );
      error.response.data = JSON.parse(data);
      error.response.config.responseType = 'json';
      throw error;
    })
    try {
      const resp = await instance.post(`/chat/stream`, obj);
      return resp.data;
    } catch (error: any) {
      if (axios.isAxiosError(error)) {
        switch (error.response?.status) {
          case 403:
            throw new InvalidApiKeyError()
          case 429:
            throw new RateLimitExceededError();
        }
      }
      throw new GeneralChatError(error.response?.data?.message);
    }
  }



  /**
   * 
   * @param searchQuery 
   * limit :10
   * offset :0
   * createdAt:date
   * sortOrder:DESC/ASC
   * @returns 
   */
  async getChatHistory(searchQuery: FindChatDto):Promise<any>{
    let obj: any = searchQuery;
    Object.keys(searchQuery).forEach((key) => {
      const typedKey = key as keyof FindChatDto;
      if (searchQuery[typedKey] === undefined) {
        delete obj[typedKey];
      }
    });
    obj['botId'] = 21;
    const instance: AxiosInstance = axios.create({
      baseURL: SERVER_URL,
      timeout: TIMEOUT,
      headers: { 'Authorization': `Bearer ${this.apiKey}` },
      params: obj
    });
    
    try {
      const resp = await instance.get(`/chat/chatHistory`);
      return resp.data;
    } catch (error: any) {
      if (axios.isAxiosError(error)) {
        switch (error.response?.status) {
          case 403:
            throw new InvalidApiKeyError();
        }
      }
      throw new GeneralChatHistoryError(error.response?.data?.message);
    }
  }

  /**
   * 
   * @param createChatDto 
   * question:string,
   * chatHistory: on/off
   * @returns 
   */

  async createChatBlob(createChatDto: CreateChatDto): Promise<any> {
    const obj: any = createChatDto;
    Object.keys(createChatDto).forEach((key) => {
      const typedKey = key as keyof CreateChatDto;
      if (createChatDto[typedKey] === undefined) {
        delete obj[typedKey];
      }
    });
    obj['model'] = 'general_assistant';
    const instance: AxiosInstance = axios.create({
      baseURL: SERVER_URL,
      timeout: TIMEOUT,
      headers: { 'Authorization': `Bearer ${this.apiKey}` }
    });
    try {
      const resp = await instance.post(`/chat/blob`, obj);
      return resp.data;
    } catch (error: any) {
      if (axios.isAxiosError(error)) {
        switch (error.response?.status) {
          case 403:
            throw new InvalidApiKeyError()
          case 429:
            throw new RateLimitExceededError();
        }
      }
      throw new GeneralChatError(error.response?.data?.message);
    }
  }
}

export const Errors = {
  GeneralChatError,
  InvalidApiKeyError, 
  RateLimitExceededError,
  GeneralChatHistoryError
}

export default { GeneralChat, Errors };